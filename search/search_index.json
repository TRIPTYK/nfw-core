{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home A NodeJS Typescript framework using Koa for routing with a lot of decorators. Requirements Typescript >= 4.5.x NodeJS >= 16.x ESM Modules enabled Modules Core HTTP JSONAPI","title":"Home"},{"location":"#home","text":"A NodeJS Typescript framework using Koa for routing with a lot of decorators.","title":"Home"},{"location":"#requirements","text":"Typescript >= 4.5.x NodeJS >= 16.x ESM Modules enabled","title":"Requirements"},{"location":"#modules","text":"Core HTTP JSONAPI","title":"Modules"},{"location":"core/1-installation/","text":"What is the core ? The is basically the starting point of every NFW modules, the core contains the main injection container and some utilities. Nothing more.","title":"What is the core ?"},{"location":"core/1-installation/#what-is-the-core","text":"The is basically the starting point of every NFW modules, the core contains the main injection container and some utilities. Nothing more.","title":"What is the core ?"},{"location":"http/","text":"Introduction The @triptyk/nfw-http contains a builder that setup complex http routing for a web app. Installation Info This module depends of @triptyk/nfw-core . pnpm install @triptyk/nfw-http","title":"Introduction"},{"location":"http/#introduction","text":"The @triptyk/nfw-http contains a builder that setup complex http routing for a web app.","title":"Introduction"},{"location":"http/#installation","text":"Info This module depends of @triptyk/nfw-core . pnpm install @triptyk/nfw-http","title":"Installation"},{"location":"http/advanced/controller-context/","text":"Controller Context The controller is available when code is executed inside the controller class. That's the case for guards , controller action and response handlers . The controller context actually contains these informations: controllerInstance: The instance of the controller controllerAction: The controller action name (A.K.A the called method) The context can be accessed by using the @ControllerContext param. Example @Controller ( '/' ) class Controller { public list ( @ControllerContext () context : ControllerContextInterface ) { console . log ( context ); } }","title":"Controller Context"},{"location":"http/advanced/controller-context/#controller-context","text":"The controller is available when code is executed inside the controller class. That's the case for guards , controller action and response handlers . The controller context actually contains these informations: controllerInstance: The instance of the controller controllerAction: The controller action name (A.K.A the called method) The context can be accessed by using the @ControllerContext param.","title":"Controller Context"},{"location":"http/advanced/controller-context/#example","text":"@Controller ( '/' ) class Controller { public list ( @ControllerContext () context : ControllerContextInterface ) { console . log ( context ); } }","title":"Example"},{"location":"http/advanced/decorators/","text":"Parameter decorators Below is the complete list of decorators available in a Controller Context . Existing decorators Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext infos (controllerAction and controllerInstance) Creating a custom decorator You can add your own decorators using createCustomDecorator(handle: (ctx: ControllerParamsContext) => unknown, name: string) . handle : the function that will be executed to get a value for the decorator. This function passes the Koa context and the arguments passed to the decorator. name : The name of the decorator. decorator/current-user.decorator.ts export function CurrentUser ( this : unknown , throwIfNotFound : boolean ) { return createCustomDecorator ( async ({ ctx , args }) => { const databaseConnection = container . resolve < MikroORM > ( databaseInjectionToken ); const context = databaseConnection . em . getContext (); const user = await context . getRepository ( UserModel ). findOne ({ id : \"amaury\" }); if ( ! user && throwIfNotFound ) { throw new Error ( \"User not found\" ); } return user ; }, 'current-user' ); } The decorator can then be called like any other decorator in a Controller Context . controller/user.controller.ts @Controller ( '/users' ) export class UsersController { @GET ( '/profile' ) profile ( @CurrentUser ( false ) currentUser : UserModel ) { return currentUser ; } } Danger At the moment, the response of the decorator is not cached. If a decorator is used once in the guard and once in the controller, it will be called twice.","title":"Parameter decorators"},{"location":"http/advanced/decorators/#parameter-decorators","text":"Below is the complete list of decorators available in a Controller Context .","title":"Parameter decorators"},{"location":"http/advanced/decorators/#existing-decorators","text":"Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext infos (controllerAction and controllerInstance)","title":"Existing decorators"},{"location":"http/advanced/decorators/#creating-a-custom-decorator","text":"You can add your own decorators using createCustomDecorator(handle: (ctx: ControllerParamsContext) => unknown, name: string) . handle : the function that will be executed to get a value for the decorator. This function passes the Koa context and the arguments passed to the decorator. name : The name of the decorator. decorator/current-user.decorator.ts export function CurrentUser ( this : unknown , throwIfNotFound : boolean ) { return createCustomDecorator ( async ({ ctx , args }) => { const databaseConnection = container . resolve < MikroORM > ( databaseInjectionToken ); const context = databaseConnection . em . getContext (); const user = await context . getRepository ( UserModel ). findOne ({ id : \"amaury\" }); if ( ! user && throwIfNotFound ) { throw new Error ( \"User not found\" ); } return user ; }, 'current-user' ); } The decorator can then be called like any other decorator in a Controller Context . controller/user.controller.ts @Controller ( '/users' ) export class UsersController { @GET ( '/profile' ) profile ( @CurrentUser ( false ) currentUser : UserModel ) { return currentUser ; } } Danger At the moment, the response of the decorator is not cached. If a decorator is used once in the guard and once in the controller, it will be called twice.","title":"Creating a custom decorator"},{"location":"http/getting%20started/1-web-server/","text":"Creating the web server First, we'll need to create your app with nfw-core's createApplication . The purpose of this function is to setup application's routing and register global elements. The routing is made using Koa Router . Info Obviously, the middleware compatibles with NFW-core are Koa-like middleware. Here's a basic application init. application.ts async function init () { // Create the app const koaApp = await createApplication ({ server : new Koa (), controllers : [ Area ] }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init (); createApplication() needs a Koa server and an array of controllers. Important Every controller needs to be registered in his parent. In this case the parent is the application itself. But it can also be another controller.","title":"Creating the web server"},{"location":"http/getting%20started/1-web-server/#creating-the-web-server","text":"First, we'll need to create your app with nfw-core's createApplication . The purpose of this function is to setup application's routing and register global elements. The routing is made using Koa Router . Info Obviously, the middleware compatibles with NFW-core are Koa-like middleware. Here's a basic application init. application.ts async function init () { // Create the app const koaApp = await createApplication ({ server : new Koa (), controllers : [ Area ] }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init (); createApplication() needs a Koa server and an array of controllers. Important Every controller needs to be registered in his parent. In this case the parent is the application itself. But it can also be another controller.","title":"Creating the web server"},{"location":"http/getting%20started/2-area/","text":"Creating an Area An area is a kind of 'super' controller that have multiple controllers as childen. Even if the concept of an Area is unknown to NFW itself, it can be easily created because controllers can be nested ! @Controller ({ // (1) controllers : [ UsersController ], routeName : '/api/v1' }) export class Area {} Behind the scene, the Http Building block is applied by the decorator. We are just telling to the builder that the controller is the parent of UsersController . This controller will also apply the prefix /api/v1 to every sub-controllers.","title":"Creating an Area"},{"location":"http/getting%20started/2-area/#creating-an-area","text":"An area is a kind of 'super' controller that have multiple controllers as childen. Even if the concept of an Area is unknown to NFW itself, it can be easily created because controllers can be nested ! @Controller ({ // (1) controllers : [ UsersController ], routeName : '/api/v1' }) export class Area {} Behind the scene, the Http Building block is applied by the decorator. We are just telling to the builder that the controller is the parent of UsersController . This controller will also apply the prefix /api/v1 to every sub-controllers.","title":"Creating an Area"},{"location":"http/getting%20started/3-controller/","text":"Creating a 'real' controller The controller is responsible of handling requests and returning a response to the client. We'll setup a basic controller to handle CRUD operations on resource users. Creating the controller In order to create a controller, decorate your class with the @Controller decorator. controller.ts interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController {} Creating HTTP endpoints To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } } Usage of parameters decorators Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut.","title":"Creating a 'real' controller"},{"location":"http/getting%20started/3-controller/#creating-a-real-controller","text":"The controller is responsible of handling requests and returning a response to the client. We'll setup a basic controller to handle CRUD operations on resource users.","title":"Creating a 'real' controller"},{"location":"http/getting%20started/3-controller/#creating-the-controller","text":"In order to create a controller, decorate your class with the @Controller decorator. controller.ts interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController {}","title":"Creating the controller"},{"location":"http/getting%20started/3-controller/#creating-http-endpoints","text":"To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } }","title":"Creating HTTP endpoints"},{"location":"http/getting%20started/3-controller/#usage-of-parameters-decorators","text":"Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut.","title":"Usage of parameters decorators"},{"location":"http/getting%20started/4-middleware/","text":"Middlewares Middlewares are simple chained functions that have access to the request context and can choose to execute other downstream middlewares. In NFW, middlewares are classes implementing the MiddlewareInterface. The MiddlewareInterface requires you to implement the \"use\" function which acts like a classic Koa middleware. middleware.ts export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { console . log ( context . method , context . url , context . ip ); await next (); } } Note By default, a new middleware instance will be created for each place the middleware is used. You can change this behavior by using the @singleton decorator. More infos Middlewares are applied on an endpoint with the @UseMiddleware decorators. Middlewares can be applied at controller level and endpoint level . application.ts // ... @Controller ( '/users' ) @UseMiddleware ( Middleware ) // (1) export class UsersController { // ... } Middleware can also be a classic koa middleware like (ctx,next) => ...","title":"Middlewares"},{"location":"http/getting%20started/4-middleware/#middlewares","text":"Middlewares are simple chained functions that have access to the request context and can choose to execute other downstream middlewares. In NFW, middlewares are classes implementing the MiddlewareInterface. The MiddlewareInterface requires you to implement the \"use\" function which acts like a classic Koa middleware. middleware.ts export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { console . log ( context . method , context . url , context . ip ); await next (); } } Note By default, a new middleware instance will be created for each place the middleware is used. You can change this behavior by using the @singleton decorator. More infos Middlewares are applied on an endpoint with the @UseMiddleware decorators. Middlewares can be applied at controller level and endpoint level . application.ts // ... @Controller ( '/users' ) @UseMiddleware ( Middleware ) // (1) export class UsersController { // ... } Middleware can also be a classic koa middleware like (ctx,next) => ...","title":"Middlewares"},{"location":"http/getting%20started/5-guard/","text":"Guards Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will throw by default a ForbiddenError. If you want to throw another Error, use throw <error> in the guard. In the example below, i've created an IpGuard that rejects when the user ip is not authorized. guard.ts export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } } Decorators can be used in guards the same way than in the controller action. Using a guard and the @Args() decorator The guards can be applied at controller or endpoint level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) export class UsersController { // ... }","title":"Guards"},{"location":"http/getting%20started/5-guard/#guards","text":"Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will throw by default a ForbiddenError. If you want to throw another Error, use throw <error> in the guard. In the example below, i've created an IpGuard that rejects when the user ip is not authorized. guard.ts export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } } Decorators can be used in guards the same way than in the controller action.","title":"Guards"},{"location":"http/getting%20started/5-guard/#using-a-guard-and-the-args-decorator","text":"The guards can be applied at controller or endpoint level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) export class UsersController { // ... }","title":"Using a guard and the @Args() decorator"},{"location":"http/getting%20started/6-response-handler/","text":"Response Handlers The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } } Using the response handler The response handler can be applied at controller and endpoint level. You must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) export class UsersController { // ... } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used.","title":"Response Handlers"},{"location":"http/getting%20started/6-response-handler/#response-handlers","text":"The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } }","title":"Response Handlers"},{"location":"http/getting%20started/6-response-handler/#using-the-response-handler","text":"The response handler can be applied at controller and endpoint level. You must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) export class UsersController { // ... } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used.","title":"Using the response handler"},{"location":"http/getting%20started/7-error-handling/","text":"Error handling There is no custom error handling at the moment, be you can easily make one using a Middleware ! export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { try { await next (); } catch ( e ) { if ( e instance ForbiddenError ) { context . status = 403 ; context . body = 'Forbidden !' ; return ; } context . status = 500 ; context . body = 'Internal Server Error!' ; } } }","title":"Error handling"},{"location":"http/getting%20started/7-error-handling/#error-handling","text":"There is no custom error handling at the moment, be you can easily make one using a Middleware ! export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { try { await next (); } catch ( e ) { if ( e instance ForbiddenError ) { context . status = 403 ; context . body = 'Forbidden !' ; return ; } context . status = 500 ; context . body = 'Internal Server Error!' ; } } }","title":"Error handling"},{"location":"http/testing/unit/1-introduction/","text":"Introduction Testing in NFW-HTTP is aimed to be easy as possible and agnostic of the testing library. For the demonstration, jest is the testing library for the different code examples. Note The functions used for testing will be refined in the future. But the testing method stays the same.","title":"Introduction"},{"location":"http/testing/unit/1-introduction/#introduction","text":"Testing in NFW-HTTP is aimed to be easy as possible and agnostic of the testing library. For the demonstration, jest is the testing library for the different code examples. Note The functions used for testing will be refined in the future. But the testing method stays the same.","title":"Introduction"},{"location":"http/testing/unit/controllers/","text":"Controllers Testing controllers can be achieved by simply instantiating the controller and calling the method. demo-http/tests/controller.test.ts import 'reflect-metadata' ; import { UsersController } from '../src/controllers/users.js' ; import { UserNotFoundError } from '../src/errors/user-not-found.js' ; import { UsersService } from '../src/services/users.js' ; let service : UsersService ; let controller : UsersController ; beforeEach (() => { service = new UsersService (); controller = new UsersController ( service ); }); it ( 'Throws error when /:name is not found' , () => { expect (() => controller . get ( 'amaury' )). toThrowError ( UserNotFoundError ); }); it ( 'Returns the user when /:name is found' , () => { const user = { name : 'amaury' }; service . users . push ( user ); expect ( controller . get ( user . name )). toStrictEqual ( user ); }); demo-http/src/controllers/users.ts import { inject } from '@triptyk/nfw-core' ; import { Controller , GET , Param , POST , UseGuard , UseResponseHandler } from '@triptyk/nfw-http' ; import { UserNotFoundError } from '../errors/user-not-found.js' ; import { AuthGuard } from '../guards/guard.js' ; import { ValidatedBody } from '../params/validated-body.js' ; import { RestResponseHandler } from '../response-handlers/rest.js' ; import { User , UsersService } from '../services/users.js' ; import { userSchema } from '../validations/user.js' ; @Controller ({ routeName : '/users' }) @UseResponseHandler ( RestResponseHandler ) @UseGuard ( AuthGuard ) export class UsersController { public constructor ( @inject ( UsersService ) public usersService : UsersService ) {} @GET ( '/:name' ) public get ( @Param ( 'name' ) param : string ) { const user = this . usersService . findOne ( param ); if ( ! user ) { throw new UserNotFoundError (); } return user ; } @POST ( '/' ) public create ( @ValidatedBody ( userSchema ) body : User ) { const user = this . usersService . createOne ( body ); return user ; } }","title":"Controllers"},{"location":"http/testing/unit/controllers/#controllers","text":"Testing controllers can be achieved by simply instantiating the controller and calling the method. demo-http/tests/controller.test.ts import 'reflect-metadata' ; import { UsersController } from '../src/controllers/users.js' ; import { UserNotFoundError } from '../src/errors/user-not-found.js' ; import { UsersService } from '../src/services/users.js' ; let service : UsersService ; let controller : UsersController ; beforeEach (() => { service = new UsersService (); controller = new UsersController ( service ); }); it ( 'Throws error when /:name is not found' , () => { expect (() => controller . get ( 'amaury' )). toThrowError ( UserNotFoundError ); }); it ( 'Returns the user when /:name is found' , () => { const user = { name : 'amaury' }; service . users . push ( user ); expect ( controller . get ( user . name )). toStrictEqual ( user ); }); demo-http/src/controllers/users.ts import { inject } from '@triptyk/nfw-core' ; import { Controller , GET , Param , POST , UseGuard , UseResponseHandler } from '@triptyk/nfw-http' ; import { UserNotFoundError } from '../errors/user-not-found.js' ; import { AuthGuard } from '../guards/guard.js' ; import { ValidatedBody } from '../params/validated-body.js' ; import { RestResponseHandler } from '../response-handlers/rest.js' ; import { User , UsersService } from '../services/users.js' ; import { userSchema } from '../validations/user.js' ; @Controller ({ routeName : '/users' }) @UseResponseHandler ( RestResponseHandler ) @UseGuard ( AuthGuard ) export class UsersController { public constructor ( @inject ( UsersService ) public usersService : UsersService ) {} @GET ( '/:name' ) public get ( @Param ( 'name' ) param : string ) { const user = this . usersService . findOne ( param ); if ( ! user ) { throw new UserNotFoundError (); } return user ; } @POST ( '/' ) public create ( @ValidatedBody ( userSchema ) body : User ) { const user = this . usersService . createOne ( body ); return user ; } }","title":"Controllers"},{"location":"http/testing/unit/guards/","text":"Guards You will need to use the callGuardWithParams method to test the guard's behavior. You can also test the guard by only calling the method's instance but you will not get the exact behavior. demo-http/tests/guard.test.ts import { callGuardWithParams , ForbiddenError } from '@triptyk/nfw-http' ; import 'reflect-metadata' ; import { AuthGuard } from '../src/guards/guard.js' ; test ( 'Guard throws when no user is provided' , async () => { const guard = new AuthGuard (); expect (() => callGuardWithParams ( guard , [ 'user' ])). rejects . toThrowError ( ForbiddenError ); }); test ( 'Guard does not throws when user admin is provided' , async () => { const guard = new AuthGuard (); await callGuardWithParams ( guard , [ 'admin' ]); }); demo-http/src/guards/guard.ts import type { GuardInterface } from '@triptyk/nfw-http' ; import { QueryParam } from '@triptyk/nfw-http' ; export class AuthGuard implements GuardInterface { public can ( @QueryParam ( 'user' ) user : string ) : boolean | Promise < boolean > { if ( user === 'admin' ) { return true ; } return false ; } }","title":"Guards"},{"location":"http/testing/unit/guards/#guards","text":"You will need to use the callGuardWithParams method to test the guard's behavior. You can also test the guard by only calling the method's instance but you will not get the exact behavior. demo-http/tests/guard.test.ts import { callGuardWithParams , ForbiddenError } from '@triptyk/nfw-http' ; import 'reflect-metadata' ; import { AuthGuard } from '../src/guards/guard.js' ; test ( 'Guard throws when no user is provided' , async () => { const guard = new AuthGuard (); expect (() => callGuardWithParams ( guard , [ 'user' ])). rejects . toThrowError ( ForbiddenError ); }); test ( 'Guard does not throws when user admin is provided' , async () => { const guard = new AuthGuard (); await callGuardWithParams ( guard , [ 'admin' ]); }); demo-http/src/guards/guard.ts import type { GuardInterface } from '@triptyk/nfw-http' ; import { QueryParam } from '@triptyk/nfw-http' ; export class AuthGuard implements GuardInterface { public can ( @QueryParam ( 'user' ) user : string ) : boolean | Promise < boolean > { if ( user === 'admin' ) { return true ; } return false ; } }","title":"Guards"},{"location":"http/testing/unit/param/","text":"Params Usually, params decorators are created by using createCustomDecorator(handle,name) . demo-http/src/params/validated-body.ts import type { ControllerParamsContext } from '@triptyk/nfw-http' ; import { createCustomDecorator } from '@triptyk/nfw-http' ; import type { ObjectSchema } from 'yup' ; export const validatedBody = async ( schema : ObjectSchema < any > , context : ControllerParamsContext < unknown > ) => { return schema . validate ( context . ctx . request . body ); }; export function ValidatedBody ( schema : ObjectSchema < any > ) { return createCustomDecorator (( context ) => validatedBody ( schema , context ), 'validated-body' ); } To test the behavior, externalize the handle method used as the first parameter. demo-http/tests/param.test.ts import 'reflect-metadata' ; import type { ControllerParamsContext } from '@triptyk/nfw-http' ; import { validatedBody } from '../src/params/validated-body.js' ; import { userSchema } from '../src/validations/user.js' ; import { ValidationError } from 'yup' ; it ( 'Throws error when schema is not valid' , async () => { const fakeContext = { ctx : { request : { body : {} } } } as ControllerParamsContext < unknown > ; expect (() => validatedBody ( userSchema , fakeContext )). rejects . toThrowError ( ValidationError ); }); it ( 'Returns body when is valid' , async () => { const fakeContext = { ctx : { request : { body : { name : 'Amaury' } } } } as ControllerParamsContext < unknown > ; const body = await validatedBody ( userSchema , fakeContext ); expect ( body ). toStrictEqual ( fakeContext . ctx . request . body ); });","title":"Params"},{"location":"http/testing/unit/param/#params","text":"Usually, params decorators are created by using createCustomDecorator(handle,name) . demo-http/src/params/validated-body.ts import type { ControllerParamsContext } from '@triptyk/nfw-http' ; import { createCustomDecorator } from '@triptyk/nfw-http' ; import type { ObjectSchema } from 'yup' ; export const validatedBody = async ( schema : ObjectSchema < any > , context : ControllerParamsContext < unknown > ) => { return schema . validate ( context . ctx . request . body ); }; export function ValidatedBody ( schema : ObjectSchema < any > ) { return createCustomDecorator (( context ) => validatedBody ( schema , context ), 'validated-body' ); } To test the behavior, externalize the handle method used as the first parameter. demo-http/tests/param.test.ts import 'reflect-metadata' ; import type { ControllerParamsContext } from '@triptyk/nfw-http' ; import { validatedBody } from '../src/params/validated-body.js' ; import { userSchema } from '../src/validations/user.js' ; import { ValidationError } from 'yup' ; it ( 'Throws error when schema is not valid' , async () => { const fakeContext = { ctx : { request : { body : {} } } } as ControllerParamsContext < unknown > ; expect (() => validatedBody ( userSchema , fakeContext )). rejects . toThrowError ( ValidationError ); }); it ( 'Returns body when is valid' , async () => { const fakeContext = { ctx : { request : { body : { name : 'Amaury' } } } } as ControllerParamsContext < unknown > ; const body = await validatedBody ( userSchema , fakeContext ); expect ( body ). toStrictEqual ( fakeContext . ctx . request . body ); });","title":"Params"},{"location":"http/testing/unit/response-handler/","text":"Response Handler Testing response handlers can be achieved by simply instantiating the response handler and calling the handle method. demo-http/tests/response-handler.test.ts import 'reflect-metadata' ; import type { RouterContext } from '@koa/router' ; import { RestResponseHandler } from '../src/response-handlers/rest.js' ; test ( 'Response is wrapped in data' , async () => { const context = { body : undefined } as RouterContext ; const fakeResponse = { username : 'hello' }; const rh = new RestResponseHandler (); await rh . handle ( fakeResponse , { attachMeta : false }, context ); expect ( context . body ). toStrictEqual ({ data : fakeResponse , meta : undefined }); }); demo-http/src/response-handlers/rest.ts import { RouterContext } from '@koa/router' ; import type { ResponseHandlerInterface } from '@triptyk/nfw-http' ; import { Ctx , Args } from '@triptyk/nfw-http' ; export class RestResponseHandler implements ResponseHandlerInterface { public handle ( lastResult : unknown , @Args () options : { attachMeta? : boolean , } | undefined , @Ctx () ctx : RouterContext ) : void | Promise < void > { ctx . body = { meta : options?.attachMeta ? 'meta' : undefined , data : lastResult }; } }","title":"Response Handler"},{"location":"http/testing/unit/response-handler/#response-handler","text":"Testing response handlers can be achieved by simply instantiating the response handler and calling the handle method. demo-http/tests/response-handler.test.ts import 'reflect-metadata' ; import type { RouterContext } from '@koa/router' ; import { RestResponseHandler } from '../src/response-handlers/rest.js' ; test ( 'Response is wrapped in data' , async () => { const context = { body : undefined } as RouterContext ; const fakeResponse = { username : 'hello' }; const rh = new RestResponseHandler (); await rh . handle ( fakeResponse , { attachMeta : false }, context ); expect ( context . body ). toStrictEqual ({ data : fakeResponse , meta : undefined }); }); demo-http/src/response-handlers/rest.ts import { RouterContext } from '@koa/router' ; import type { ResponseHandlerInterface } from '@triptyk/nfw-http' ; import { Ctx , Args } from '@triptyk/nfw-http' ; export class RestResponseHandler implements ResponseHandlerInterface { public handle ( lastResult : unknown , @Args () options : { attachMeta? : boolean , } | undefined , @Ctx () ctx : RouterContext ) : void | Promise < void > { ctx . body = { meta : options?.attachMeta ? 'meta' : undefined , data : lastResult }; } }","title":"Response Handler"},{"location":"http/testing/unit/whole-action/","text":"Testing the whole action Testing the whole controller method (guards + params + action + response handler) consists of generating the middleware associated with the controller method and calling it with a Koa context. The magic class is the ControllerActionBuilder. It produces a middleware based on the decorators applied to it and the method name. const action = new ControllerActionBuilder ( controller , // (1) container . resolve ( MetadataStorage ), // (2) 'get' // (3) ); action . build (); // It builds the middleware. The controller instance The metadata storage The controller method to test demo-http/tests/action.test.ts import 'reflect-metadata' ; import type { RouterContext } from '@koa/router' ; import { container } from '@triptyk/nfw-core' ; import { ControllerActionBuilder , MetadataStorage } from '@triptyk/nfw-http' ; import { UsersController } from '../src/controllers/users.js' ; import { UsersService } from '../src/services/users.js' ; import httpMocks from 'node-mocks-http' ; import Application from 'koa' ; function createFakeContext () { return { req : httpMocks.createRequest ({ method : 'GET' }), res : httpMocks.createResponse (), app : new Application (), query : { user : 'admin' }, params : { name : 'amaury' }, body : undefined } as unknown as RouterContext ; } function setupServiceAndController () { const userService = container . resolve ( UsersService ); userService . users . push ({ name : 'amaury' }); const controller = new UsersController ( userService ); return controller ; } it ( 'Whole action set ctx.body with correct data' , async () => { const controller = setupServiceAndController (); const action = new ControllerActionBuilder ( controller , container . resolve ( MetadataStorage ), 'get' ); const fakeContext = createFakeContext (); await action . build ()( fakeContext , async () => {} ); expect ( fakeContext . body ). toStrictEqual ({ data : { name : 'amaury' }, meta : undefined }); });","title":"Testing the whole action"},{"location":"http/testing/unit/whole-action/#testing-the-whole-action","text":"Testing the whole controller method (guards + params + action + response handler) consists of generating the middleware associated with the controller method and calling it with a Koa context. The magic class is the ControllerActionBuilder. It produces a middleware based on the decorators applied to it and the method name. const action = new ControllerActionBuilder ( controller , // (1) container . resolve ( MetadataStorage ), // (2) 'get' // (3) ); action . build (); // It builds the middleware. The controller instance The metadata storage The controller method to test demo-http/tests/action.test.ts import 'reflect-metadata' ; import type { RouterContext } from '@koa/router' ; import { container } from '@triptyk/nfw-core' ; import { ControllerActionBuilder , MetadataStorage } from '@triptyk/nfw-http' ; import { UsersController } from '../src/controllers/users.js' ; import { UsersService } from '../src/services/users.js' ; import httpMocks from 'node-mocks-http' ; import Application from 'koa' ; function createFakeContext () { return { req : httpMocks.createRequest ({ method : 'GET' }), res : httpMocks.createResponse (), app : new Application (), query : { user : 'admin' }, params : { name : 'amaury' }, body : undefined } as unknown as RouterContext ; } function setupServiceAndController () { const userService = container . resolve ( UsersService ); userService . users . push ({ name : 'amaury' }); const controller = new UsersController ( userService ); return controller ; } it ( 'Whole action set ctx.body with correct data' , async () => { const controller = setupServiceAndController (); const action = new ControllerActionBuilder ( controller , container . resolve ( MetadataStorage ), 'get' ); const fakeContext = createFakeContext (); await action . build ()( fakeContext , async () => {} ); expect ( fakeContext . body ). toStrictEqual ({ data : { name : 'amaury' }, meta : undefined }); });","title":"Testing the whole action"},{"location":"jsonapi/","text":"Introduction The @triptyk/nfw-jsonapi contains a builder that setups jsonapi endpoints and resources. Installation Info This module depends of : @triptyk/nfw-core , @triptyk/nfw-http , @triptyk/nfw-mikro-orm . pnpm install @triptyk/nfw-jsonapi Danger This module is experimental and subject to drastical changes","title":"Introduction"},{"location":"jsonapi/#introduction","text":"The @triptyk/nfw-jsonapi contains a builder that setups jsonapi endpoints and resources.","title":"Introduction"},{"location":"jsonapi/#installation","text":"Info This module depends of : @triptyk/nfw-core , @triptyk/nfw-http , @triptyk/nfw-mikro-orm . pnpm install @triptyk/nfw-jsonapi Danger This module is experimental and subject to drastical changes","title":"Installation"},{"location":"jsonapi/authorizers/","text":"","title":"Authorizers"},{"location":"jsonapi/context/","text":"The jsonapi request context In every request, a JsonApiContext object is created containing many practical informations. { koaContext : RouterContext , query? : QueryParser < TModel > , method : JsonApiMethod , currentUser? : unknown , resource : ResourceMeta < TModel , TResource > , } The Koa context The query parser The current jsonapi method (GET/CREATE/UPDATE/...) The current user for the request The resource binded to this context This object can be accessed in : resources controllers (via parameter decorators) authorizers deserializers serializers query parsers","title":"The jsonapi request context"},{"location":"jsonapi/context/#the-jsonapi-request-context","text":"In every request, a JsonApiContext object is created containing many practical informations. { koaContext : RouterContext , query? : QueryParser < TModel > , method : JsonApiMethod , currentUser? : unknown , resource : ResourceMeta < TModel , TResource > , } The Koa context The query parser The current jsonapi method (GET/CREATE/UPDATE/...) The current user for the request The resource binded to this context This object can be accessed in : resources controllers (via parameter decorators) authorizers deserializers serializers query parsers","title":"The jsonapi request context"},{"location":"jsonapi/controllers/","text":"Controllers The controller is creating endpoints based on a Resource . Overview @JsonApiController ( UserResource ) export class UserController { @JsonApiList () public async list () {} @JsonApiGet () public async get () {} @JsonApiCreate () public async create () {} @JsonApiUpdate () public async update () {} @JsonApiDelete () public async delete () {} @JsonApiGetRelationships () public async relationships () {} @JsonApiGetRelated () public async related () {} } Each method decorator creates a jsonapi endpoint. Hint The controller can use @UseMiddleware from @triptyk/nfw-http on any jsonapi endpoint. Hint Any @triptyk/nfw-http endpoints can also be applied in the controller's class. Any jsonapi endpoint can be disabled by removing the corresponding method. A list only controller @JsonApiController ( UserResource ) export class UserController { @JsonApiList () public async list () {} } Info The ADD/REMOVE/UPDATE relationships endpoints are currently not implemented.","title":"Controllers"},{"location":"jsonapi/controllers/#controllers","text":"The controller is creating endpoints based on a Resource .","title":"Controllers"},{"location":"jsonapi/controllers/#overview","text":"@JsonApiController ( UserResource ) export class UserController { @JsonApiList () public async list () {} @JsonApiGet () public async get () {} @JsonApiCreate () public async create () {} @JsonApiUpdate () public async update () {} @JsonApiDelete () public async delete () {} @JsonApiGetRelationships () public async relationships () {} @JsonApiGetRelated () public async related () {} } Each method decorator creates a jsonapi endpoint. Hint The controller can use @UseMiddleware from @triptyk/nfw-http on any jsonapi endpoint. Hint Any @triptyk/nfw-http endpoints can also be applied in the controller's class. Any jsonapi endpoint can be disabled by removing the corresponding method. A list only controller @JsonApiController ( UserResource ) export class UserController { @JsonApiList () public async list () {} } Info The ADD/REMOVE/UPDATE relationships endpoints are currently not implemented.","title":"Overview"},{"location":"jsonapi/deserializers/","text":"Deserializers The purpose of the deserializer is to transform your request body into a Resource instance. By default, the ResourceDeserializer is used.","title":"Deserializers"},{"location":"jsonapi/deserializers/#deserializers","text":"The purpose of the deserializer is to transform your request body into a Resource instance. By default, the ResourceDeserializer is used.","title":"Deserializers"},{"location":"jsonapi/getting%20started/","text":"","title":"Getting started"},{"location":"jsonapi/global-filter/","text":"The context filter In each request, a mikro-orm @Filter 'context' is defined. It allows you to create pseudo-views from the current jsonapi context. @Entity () @Filter ({ name : 'context' , cond : ({ jsonApiContext } : { jsonApiContext : JsonApiContext < any > }) => { // user can only get itself return { id : ( jsonApiContext ? . currentUser as UserModel ). id } } }) export class UserModel extends BaseEntity < UserModel , 'id' > {}","title":"The context filter"},{"location":"jsonapi/global-filter/#the-context-filter","text":"In each request, a mikro-orm @Filter 'context' is defined. It allows you to create pseudo-views from the current jsonapi context. @Entity () @Filter ({ name : 'context' , cond : ({ jsonApiContext } : { jsonApiContext : JsonApiContext < any > }) => { // user can only get itself return { id : ( jsonApiContext ? . currentUser as UserModel ). id } } }) export class UserModel extends BaseEntity < UserModel , 'id' > {}","title":"The context filter"},{"location":"jsonapi/query-parser/","text":"The Query parser The purpose of the query parser is to validate and translate your query string into a structured element. Danger Subject to changes.","title":"The Query parser"},{"location":"jsonapi/query-parser/#the-query-parser","text":"The purpose of the query parser is to validate and translate your query string into a structured element. Danger Subject to changes.","title":"The Query parser"},{"location":"jsonapi/registry/","text":"The registry The registry is where you can find all the informations needed for a resource.","title":"The registry"},{"location":"jsonapi/registry/#the-registry","text":"The registry is where you can find all the informations needed for a resource.","title":"The registry"},{"location":"jsonapi/resource%20services/","text":"","title":"Resource services"},{"location":"jsonapi/resources/","text":"Resources The resources are the main elements of this frameworks. Purpose A resource defines a jsonapi document. A resource contains attributes and relationships . A resource is based on a MikroORM Model . A resource defines which fields should be serializable, deserializable, filterable, sortable and includeable. A resource defines the relationships with other resources. Example of a resource @JsonApiResource ({ entity : UserModel , entityName : 'users' }) export class UserResource extends Resource < UserModel > { @Attribute ({ filterable : { $eq : true }, sortable : [ 'ASC' ] }) public declare id : string ; @Attribute () public declare username : string ; @Attribute () public declare role : string ; @Relationship ({ otherResource : 'ArticleResource' }) public declare articles : ArticleResource []; }","title":"Resources"},{"location":"jsonapi/resources/#resources","text":"The resources are the main elements of this frameworks.","title":"Resources"},{"location":"jsonapi/resources/#purpose","text":"A resource defines a jsonapi document. A resource contains attributes and relationships . A resource is based on a MikroORM Model . A resource defines which fields should be serializable, deserializable, filterable, sortable and includeable. A resource defines the relationships with other resources. Example of a resource @JsonApiResource ({ entity : UserModel , entityName : 'users' }) export class UserResource extends Resource < UserModel > { @Attribute ({ filterable : { $eq : true }, sortable : [ 'ASC' ] }) public declare id : string ; @Attribute () public declare username : string ; @Attribute () public declare role : string ; @Relationship ({ otherResource : 'ArticleResource' }) public declare articles : ArticleResource []; }","title":"Purpose"},{"location":"jsonapi/serializers/","text":"Serializers The purpose of the serializer is to transform a Resource into a jsonapi payload. It will also apply the links, meta and check which attributes should be sent to the client. By default, the ResourceSerializer is used. The serializer will also check if the related and relationships links should be included into the payload. In case the relationships endpoint of the controller is disabled.","title":"Serializers"},{"location":"jsonapi/serializers/#serializers","text":"The purpose of the serializer is to transform a Resource into a jsonapi payload. It will also apply the links, meta and check which attributes should be sent to the client. By default, the ResourceSerializer is used. The serializer will also check if the related and relationships links should be included into the payload. In case the relationships endpoint of the controller is disabled.","title":"Serializers"},{"location":"mikro-orm/1-index/","text":"Introduction Bootstraps the use of Mikro-ORM in nfw-modules. Installation Info This module depends of : @triptyk/nfw-core . pnpm install @triptyk/nfw-mikro-orm","title":"Introduction"},{"location":"mikro-orm/1-index/#introduction","text":"Bootstraps the use of Mikro-ORM in nfw-modules.","title":"Introduction"},{"location":"mikro-orm/1-index/#installation","text":"Info This module depends of : @triptyk/nfw-core . pnpm install @triptyk/nfw-mikro-orm","title":"Installation"},{"location":"mikro-orm/2-setup/","text":"Setup The init method creates a MikroORM connection who is resolvable in the DI container. import { init } from '@triptyk/nfw-mikro-orm' ; import { container } from '@triptyk/nfw-core' ; import { MikroORM } from '@mikro-orm/core' ; await init ({ dbName : ':memory:' , type : 'sqlite' , entities : < entities > }); // ... container . resolve ( MikroORM );","title":"Setup"},{"location":"mikro-orm/2-setup/#setup","text":"The init method creates a MikroORM connection who is resolvable in the DI container. import { init } from '@triptyk/nfw-mikro-orm' ; import { container } from '@triptyk/nfw-core' ; import { MikroORM } from '@mikro-orm/core' ; await init ({ dbName : ':memory:' , type : 'sqlite' , entities : < entities > }); // ... container . resolve ( MikroORM );","title":"Setup"},{"location":"mikro-orm/3-injection/","text":"Injection injecting a MikroORM connection can be done by the help of @inject decorator from @triptyk/nfw-core . @singleton () class UserController { public constructor ( @inject ( MikroORM ) public mikroOrm : MikroORM ) {} } Injecting a repository Injecting a repository can be achieved by using the @injectRepository decorator from @triptyk/nfw-mikro-orm . @singleton () class UserController { public constructor ( @injectRepository ( UserModel ) public userRepository : EntityRepository < UserModel > ) {} }","title":"Injection"},{"location":"mikro-orm/3-injection/#injection","text":"injecting a MikroORM connection can be done by the help of @inject decorator from @triptyk/nfw-core . @singleton () class UserController { public constructor ( @inject ( MikroORM ) public mikroOrm : MikroORM ) {} }","title":"Injection"},{"location":"mikro-orm/3-injection/#injecting-a-repository","text":"Injecting a repository can be achieved by using the @injectRepository decorator from @triptyk/nfw-mikro-orm . @singleton () class UserController { public constructor ( @injectRepository ( UserModel ) public userRepository : EntityRepository < UserModel > ) {} }","title":"Injecting a repository"}]}