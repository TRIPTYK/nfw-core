{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NFW-CORE A NodeJS Typescript framework using Koa for routing with a lot of syntax sugar . Features Controller based routing Parameters decorators Easy custom decorators Smart decorators MikroORM support Dependency injections Full Typescript","title":"Home"},{"location":"#nfw-core","text":"A NodeJS Typescript framework using Koa for routing with a lot of syntax sugar .","title":"NFW-CORE"},{"location":"#features","text":"Controller based routing Parameters decorators Easy custom decorators Smart decorators MikroORM support Dependency injections Full Typescript","title":"Features"},{"location":"advanced/controller-context/","text":"Controller Context The controller context is when code is executed inside the controller class. That's the case for guards , controller action and response handlers .","title":"Controller context"},{"location":"advanced/controller-context/#controller-context","text":"The controller context is when code is executed inside the controller class. That's the case for guards , controller action and response handlers .","title":"Controller Context"},{"location":"advanced/decorators/","text":"Parameter decorators Below is the complete list of decorators available in a Controller Context . Existing decorators Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext Creating a custom decorator You can add your own decorators using createCustomDecorator(handle: (ctx: ControllerParamsContext) => unknown, name: string, cache = false, args: unknown[] = []) . handle : the function that will be executed to get a value for the decorator. This function passes the Koa context and the arguments passed to the decorator. name : The name of the decorator, will be used for caching. cache : Enable decorator caching. args : The arguments passed to the decorator decorator/current-user.decorator.ts import { MikroORM } from '@mikro-orm/core' ; import { container , createCustomDecorator , databaseInjectionToken } from '@triptyk/nfw-core' export function CurrentUser ( this : unknown , throwIfNotFound : boolean ) { return createCustomDecorator ( async ({ ctx , args }) => { const databaseConnection = container . resolve < MikroORM > ( databaseInjectionToken ); const context = databaseConnection . em . getContext (); const user = await context . getRepository ( UserModel ). findOne ({ id : \"amaury\" }); if ( ! user && throwIfNotFound ) { throw new Error ( \"User not found\" ); } return user ; }, 'current-user' , true , [ throwIfNotFound ]); } The decorator can then be called like any other decorator in a Controller Context . controller/user.controller.ts import { Controller , GET , UseGuard } from '@triptyk/nfw-core' ; import { CurrentUser } from '../decorator/current-user.decorator.js' ; import { AuthorizeGuard } from '../guard/authorize.guard.js' ; import { UserModel } from '../model/user.model.js' ; @Controller ( '/users' ) export class UsersController { @GET ( '/profile' ) @UseGuard ( AuthorizeGuard ) profile ( @CurrentUser ( false ) currentUser : UserModel ) { return currentUser ; } } Decorator caching Let's analyse the line below : createCustomDecorator ( handle , 'current-user' , // (1) true , // (2) [ throwIfNotFound ] // (3) ); The name of the decorator 'current-user' Caching enabled The array of arguments You'll need to toggle the caching property to true . The array of arguments will be concatenated with the name to form a hash in order to reuse the decorator's result. For example, using the @CurrentUser(false) decorator will produce this hash : current-userfalse . If @CurrentUser(false) is used in another place in the same request , the result will be reused instead of calling the handle again. Warning The caching is request-wide, if you call the same endpoint again, it may not produce the same result.","title":"Parameters decorators"},{"location":"advanced/decorators/#parameter-decorators","text":"Below is the complete list of decorators available in a Controller Context .","title":"Parameter decorators"},{"location":"advanced/decorators/#existing-decorators","text":"Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext","title":"Existing decorators"},{"location":"advanced/decorators/#creating-a-custom-decorator","text":"You can add your own decorators using createCustomDecorator(handle: (ctx: ControllerParamsContext) => unknown, name: string, cache = false, args: unknown[] = []) . handle : the function that will be executed to get a value for the decorator. This function passes the Koa context and the arguments passed to the decorator. name : The name of the decorator, will be used for caching. cache : Enable decorator caching. args : The arguments passed to the decorator decorator/current-user.decorator.ts import { MikroORM } from '@mikro-orm/core' ; import { container , createCustomDecorator , databaseInjectionToken } from '@triptyk/nfw-core' export function CurrentUser ( this : unknown , throwIfNotFound : boolean ) { return createCustomDecorator ( async ({ ctx , args }) => { const databaseConnection = container . resolve < MikroORM > ( databaseInjectionToken ); const context = databaseConnection . em . getContext (); const user = await context . getRepository ( UserModel ). findOne ({ id : \"amaury\" }); if ( ! user && throwIfNotFound ) { throw new Error ( \"User not found\" ); } return user ; }, 'current-user' , true , [ throwIfNotFound ]); } The decorator can then be called like any other decorator in a Controller Context . controller/user.controller.ts import { Controller , GET , UseGuard } from '@triptyk/nfw-core' ; import { CurrentUser } from '../decorator/current-user.decorator.js' ; import { AuthorizeGuard } from '../guard/authorize.guard.js' ; import { UserModel } from '../model/user.model.js' ; @Controller ( '/users' ) export class UsersController { @GET ( '/profile' ) @UseGuard ( AuthorizeGuard ) profile ( @CurrentUser ( false ) currentUser : UserModel ) { return currentUser ; } }","title":"Creating a custom decorator"},{"location":"advanced/decorators/#decorator-caching","text":"Let's analyse the line below : createCustomDecorator ( handle , 'current-user' , // (1) true , // (2) [ throwIfNotFound ] // (3) ); The name of the decorator 'current-user' Caching enabled The array of arguments You'll need to toggle the caching property to true . The array of arguments will be concatenated with the name to form a hash in order to reuse the decorator's result. For example, using the @CurrentUser(false) decorator will produce this hash : current-userfalse . If @CurrentUser(false) is used in another place in the same request , the result will be reused instead of calling the handle again. Warning The caching is request-wide, if you call the same endpoint again, it may not produce the same result.","title":"Decorator caching"},{"location":"advanced/mikro-orm/","text":"MikroORM Support Even if optionnal, NFW-Core supports MikroORM by passing a mikroORMConnection to the app. const orm = await MikroORM . init ({ ... // MikroORM options }); const koaApp = await createApplication ({ // ... mikroORMConnection : orm , mikroORMContext : true , // (1) }); See MikroORM request context Injecting the MikroORM connection You can use @inject(databaseInjectionToken) that resolves to the mikroORMConnection you passed in the createApplication function. controller/user.controller.ts import { MikroORM } from '@mikro-orm/core' ; import { Controller , databaseInjectionToken , GET , inject , injectable } from '@triptyk/nfw-core' ; @Controller ( '/users' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( databaseInjectionToken ) private mikroORM : MikroORM ) {} @GET ( '/meta' ) meta () { return this . mikroORM . getMetadata (). find ( 'UserModel' ) ? . path ; } } Injecting repositories You can use @InjectRepository(<Model>) . controller/user.controller.ts import { EntityRepository } from '@mikro-orm/sqlite' ; import { Controller , GET , injectable , InjectRepository } from '@triptyk/nfw-core' ; import { UserModel } from '../model/user.model.js' ; @Controller ( '/users' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @InjectRepository ( UserModel ) private userRepository : EntityRepository < UserModel > ) {} @GET ( '/' ) list () { return this . userRepository . find ({}); } }","title":"MikroORM"},{"location":"advanced/mikro-orm/#mikroorm-support","text":"Even if optionnal, NFW-Core supports MikroORM by passing a mikroORMConnection to the app. const orm = await MikroORM . init ({ ... // MikroORM options }); const koaApp = await createApplication ({ // ... mikroORMConnection : orm , mikroORMContext : true , // (1) }); See MikroORM request context","title":"MikroORM Support"},{"location":"advanced/mikro-orm/#injecting-the-mikroorm-connection","text":"You can use @inject(databaseInjectionToken) that resolves to the mikroORMConnection you passed in the createApplication function. controller/user.controller.ts import { MikroORM } from '@mikro-orm/core' ; import { Controller , databaseInjectionToken , GET , inject , injectable } from '@triptyk/nfw-core' ; @Controller ( '/users' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( databaseInjectionToken ) private mikroORM : MikroORM ) {} @GET ( '/meta' ) meta () { return this . mikroORM . getMetadata (). find ( 'UserModel' ) ? . path ; } }","title":"Injecting the MikroORM connection"},{"location":"advanced/mikro-orm/#injecting-repositories","text":"You can use @InjectRepository(<Model>) . controller/user.controller.ts import { EntityRepository } from '@mikro-orm/sqlite' ; import { Controller , GET , injectable , InjectRepository } from '@triptyk/nfw-core' ; import { UserModel } from '../model/user.model.js' ; @Controller ( '/users' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @InjectRepository ( UserModel ) private userRepository : EntityRepository < UserModel > ) {} @GET ( '/' ) list () { return this . userRepository . find ({}); } }","title":"Injecting repositories"},{"location":"getting-started/controller/","text":"The controller is responsible of handling requests and returning a response to the client. We'll setup a basic controller to handle CRUD operations on resource users. Creating the controller In order to create a controller, decorate your class with the @Controller decorator. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { } Creating HTTP endpoints To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } } Usage of parameters decorators Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut. See more here . Registering the controller You need to register each controller in the controllers property. application.ts import createApplication from '@triptyk/nfw-core' ; import { UsersController } from './controller.js' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [ UsersController ], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init ();","title":"Controller"},{"location":"getting-started/controller/#creating-the-controller","text":"In order to create a controller, decorate your class with the @Controller decorator. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { }","title":"Creating the controller"},{"location":"getting-started/controller/#creating-http-endpoints","text":"To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } }","title":"Creating HTTP endpoints"},{"location":"getting-started/controller/#usage-of-parameters-decorators","text":"Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut. See more here .","title":"Usage of parameters decorators"},{"location":"getting-started/controller/#registering-the-controller","text":"You need to register each controller in the controllers property. application.ts import createApplication from '@triptyk/nfw-core' ; import { UsersController } from './controller.js' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [ UsersController ], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init ();","title":"Registering the controller"},{"location":"getting-started/guard/","text":"Guards Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will return by default a 403 forbidden error. The code and the message returned can be customised in the Guard class. In the example below, i've created an IpGuard that rejets when the user ip is not authorized. guard.ts import { Args , GuardInterface , Ip } from '@triptyk/nfw-core' ; export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } code = 403 ; message = 'Your ip is not allowed' ; } Decorators can be used in guards the same way than in the controller action. Use the guard and the @Args() decorator The guards can be applied at controller , route or application level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Guard"},{"location":"getting-started/guard/#guards","text":"Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will return by default a 403 forbidden error. The code and the message returned can be customised in the Guard class. In the example below, i've created an IpGuard that rejets when the user ip is not authorized. guard.ts import { Args , GuardInterface , Ip } from '@triptyk/nfw-core' ; export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } code = 403 ; message = 'Your ip is not allowed' ; } Decorators can be used in guards the same way than in the controller action.","title":"Guards"},{"location":"getting-started/guard/#use-the-guard-and-the-args-decorator","text":"The guards can be applied at controller , route or application level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Use the guard and the @Args() decorator"},{"location":"getting-started/installation/","text":"Installation npm npm i @triptyk/nfw-core pnpm pnpm i @triptyk/nfw-core yarn yarn add @triptyk/nfw-core","title":"Installation"},{"location":"getting-started/installation/#installation","text":"","title":"Installation"},{"location":"getting-started/installation/#npm","text":"npm i @triptyk/nfw-core","title":"npm"},{"location":"getting-started/installation/#pnpm","text":"pnpm i @triptyk/nfw-core","title":"pnpm"},{"location":"getting-started/installation/#yarn","text":"yarn add @triptyk/nfw-core","title":"yarn"},{"location":"getting-started/middleware/","text":"Middleware are simple chained functions that have access to the request context and can choose to execute other downstream middlewares. In NFW, middlewares are classes implementing the MiddlewareInterface. The MiddlewareInterface requires you to implement the \"use\" function which acts like a classic Koa middleware. middleware.ts import { RouterContext } from '@koa/router' import { injectable , MiddlewareInterface } from '@triptyk/nfw-core' ; import { Next } from 'koa' ; export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { // eslint-disable-next-line no-console console . log ( context . method , context . url , context . ip ); await next (); } } Note By default, a new middleware instance will be created for each place the middleware is used. You can change this behavior by using the @singleton decorator. More infos Middlewares are applied on an endpoint with the @UseMiddleware decorators. Middleware can be applied at application level (globalMiddlewares), controller level and route level . application.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @Controller ( '/users' ) @UseMiddleware ( Middleware ) // (1) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } } Middleware can also be a classic koa middleware like (ctx,next) => ...","title":"Middleware"},{"location":"getting-started/response-handler/","text":"Response Handlers The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } } Using the response handler The response handler can be applied at controller , route or application level. For the controller and route level, you must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard , UseResponseHandler } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { MetaResponseHandler } from './response-handler.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) @UseResponseHandler ( MetaResponseHandler , 'Returns all users of the app' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used. Future improvements In the future, response handlers will probably be chainable.","title":"Response handler"},{"location":"getting-started/response-handler/#response-handlers","text":"The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } }","title":"Response Handlers"},{"location":"getting-started/response-handler/#using-the-response-handler","text":"The response handler can be applied at controller , route or application level. For the controller and route level, you must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard , UseResponseHandler } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { MetaResponseHandler } from './response-handler.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) @UseResponseHandler ( MetaResponseHandler , 'Returns all users of the app' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used. Future improvements In the future, response handlers will probably be chainable.","title":"Using the response handler"},{"location":"getting-started/service/","text":"Service There's no specific interfaces to declare a service, all you need to do is decorate your class with @singleton . The rest is up to you. For this example, we're going to create a users service to manage CRUD of users. Create the service service.ts import { singleton } from 'tsyringe' ; export interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @singleton () export class UsersService { addUser ( user : User ) { users . push ( user ); return user ; } removeUser ( name : string ) { users = users . filter (( e ) => e . name === name ); } updateUser ( name : string , body : Partial < User > ) { const idx = users . findIndex (( e ) => e . name === name ); if ( idx === - 1 ) { throw new Error ( 'User not found' ); } return users [ idx ] = { ... users [ idx ], ... body }; } getUser ( name : string ) { return users . find (( e ) => e . name === name ); } getUsers () { return users ; } } Inject the service For the service to be used you need to @inject it and mark the class as @injectable . controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Service"},{"location":"getting-started/service/#service","text":"There's no specific interfaces to declare a service, all you need to do is decorate your class with @singleton . The rest is up to you. For this example, we're going to create a users service to manage CRUD of users.","title":"Service"},{"location":"getting-started/service/#create-the-service","text":"service.ts import { singleton } from 'tsyringe' ; export interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @singleton () export class UsersService { addUser ( user : User ) { users . push ( user ); return user ; } removeUser ( name : string ) { users = users . filter (( e ) => e . name === name ); } updateUser ( name : string , body : Partial < User > ) { const idx = users . findIndex (( e ) => e . name === name ); if ( idx === - 1 ) { throw new Error ( 'User not found' ); } return users [ idx ] = { ... users [ idx ], ... body }; } getUser ( name : string ) { return users . find (( e ) => e . name === name ); } getUsers () { return users ; } }","title":"Create the service"},{"location":"getting-started/service/#inject-the-service","text":"For the service to be used you need to @inject it and mark the class as @injectable . controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Inject the service"},{"location":"getting-started/web-server/","text":"First, we'll need to create the web-server itself with the createApplication function. The purpose of this function is to setup application's routing and register global elements. The routing is made using Koa Router . Info Obviously, the middleware compatibles with NFW-core are Koa-like middleware. application.ts import createApplication from '@triptyk/nfw-core' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' // (1) }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init (); The baseRoute is the prefix before all controller's routes.","title":"Creating the Web server"}]}