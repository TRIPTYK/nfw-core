{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"NFW-CORE A NodeJS Typescript framework using Koa for routing with a lot of syntax sugar . Features Controller based routing Parameters decorators Easy custom decorators Smart decorators MikroORM support Dependency injections Full Typescript Goals As flexible as possible and customizable Easy to learn Efficient","title":"Home"},{"location":"#nfw-core","text":"A NodeJS Typescript framework using Koa for routing with a lot of syntax sugar .","title":"NFW-CORE"},{"location":"#features","text":"Controller based routing Parameters decorators Easy custom decorators Smart decorators MikroORM support Dependency injections Full Typescript","title":"Features"},{"location":"#goals","text":"As flexible as possible and customizable Easy to learn Efficient","title":"Goals"},{"location":"advanced/controller-context/","text":"","title":"Controller context"},{"location":"advanced/decorators/","text":"Parameter decorators Below is the complete list of decorators available in a Controller-Context . Existing decorators Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext Creating a custom decorator","title":"Custom decorators"},{"location":"advanced/decorators/#parameter-decorators","text":"Below is the complete list of decorators available in a Controller-Context .","title":"Parameter decorators"},{"location":"advanced/decorators/#existing-decorators","text":"Decorator Description @Body() returns ctx.request.body or ctx.body if previous one is undefined @Param(name: string) Returns the value of an URL parameter (ex : /:id ) @Params() Returns all the url params @Query() Returns all the query parameters @QueryParam(name: string) Returns the value of a query param (ex : /:id ) @Ip() Returns ctx.ip @Origin() Returns ctx.origin @Method() Returns the HTTP Method ctx.method @Ctx() Returns Koa-router ctx ( RouterContext ) @Args() Special NFW decorator, it returns the args passed to a ResponseHandler or a Guard @ControllerContext() Special NFW decorator, it returns the current ControllerContext","title":"Existing decorators"},{"location":"advanced/decorators/#creating-a-custom-decorator","text":"","title":"Creating a custom decorator"},{"location":"advanced/mikro-orm/","text":"MikroORM Support Even if optionnal, NFW-Core supports MikroORM by passing a mikroORMConnection. const orm = await MikroORM . init ({ ... // MikroORM options }); const koaApp = await createApplication ({ // ... mikroORMConnection : orm , mikroORMContext : true , }); Injecting the MikroORM connection Injecting repositories","title":"MikroORM"},{"location":"advanced/mikro-orm/#mikroorm-support","text":"Even if optionnal, NFW-Core supports MikroORM by passing a mikroORMConnection. const orm = await MikroORM . init ({ ... // MikroORM options }); const koaApp = await createApplication ({ // ... mikroORMConnection : orm , mikroORMContext : true , });","title":"MikroORM Support"},{"location":"advanced/mikro-orm/#injecting-the-mikroorm-connection","text":"","title":"Injecting the MikroORM connection"},{"location":"advanced/mikro-orm/#injecting-repositories","text":"","title":"Injecting repositories"},{"location":"getting-started/controller/","text":"The controller is responsible of handling requests and returning a response to the client. We'll setup a basic controller to handle CRUD operations on resource users. Creating the controller In order to create a controller, decorate your class with the @Controller decorator. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { } Creating HTTP endpoints To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } } Usage of parameters decorators Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut. See more here . Registering the controller You need to register each controller in the controllers property. application.ts import createApplication from '@triptyk/nfw-core' ; import { UsersController } from './controller.js' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [ UsersController ], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init ();","title":"Controller"},{"location":"getting-started/controller/#creating-the-controller","text":"In order to create a controller, decorate your class with the @Controller decorator. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { }","title":"Creating the controller"},{"location":"getting-started/controller/#creating-http-endpoints","text":"To create an endpoint, you must use a decorator corresponding to the needed HTTP method. controller.ts import { Controller } from '@triptyk/nfw-core' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' } ]; @Controller ( '/users' ) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } }","title":"Creating HTTP endpoints"},{"location":"getting-started/controller/#usage-of-parameters-decorators","text":"Parameters decorators are parameters that returns a result based on the request. Per example, above the @Body() decorator returns the equivalent of ctx.request.body and the @Param(\"something\") is equivalent to ctx.params[something] . Hint Parameters decorators can be much more complex than just being a shortcut. See more here .","title":"Usage of parameters decorators"},{"location":"getting-started/controller/#registering-the-controller","text":"You need to register each controller in the controllers property. application.ts import createApplication from '@triptyk/nfw-core' ; import { UsersController } from './controller.js' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [ UsersController ], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init ();","title":"Registering the controller"},{"location":"getting-started/guard/","text":"Guards Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will return by default a 403 forbidden error. The code and the message returned can be customised in the Guard class. In the example below, i've created an IpGuard that rejets when the user ip is not authorized. guard.ts import { Args , GuardInterface , Ip } from '@triptyk/nfw-core' ; export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } code = 403 ; message = 'Your ip is not allowed' ; } Decorators can be used in guards the same way than in the controller action. Use the guard and the @Args() decorator The guards can be applied at controller , route or application level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Guard"},{"location":"getting-started/guard/#guards","text":"Guards are pieces of code that executes one by one before the controller action, if some guard throws an error or returns false, it will return by default a 403 forbidden error. The code and the message returned can be customised in the Guard class. In the example below, i've created an IpGuard that rejets when the user ip is not authorized. guard.ts import { Args , GuardInterface , Ip } from '@triptyk/nfw-core' ; export class IpGuard implements GuardInterface { // (1) can ( @Ip () ip : string , @Args () [ allowedIp ] : [ string ]) { return ip === allowedIp ; } code = 403 ; message = 'Your ip is not allowed' ; } Decorators can be used in guards the same way than in the controller action.","title":"Guards"},{"location":"getting-started/guard/#use-the-guard-and-the-args-decorator","text":"The guards can be applied at controller , route or application level. For the controller and route level, you must use the @UseGuard(GuardClass, ...args) decorator. The args passed to the @UseGuard will be passed to the guard and can be retrieved in the guard by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::ff' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Use the guard and the @Args() decorator"},{"location":"getting-started/installation/","text":"Installation npm npm i @triptyk/nfw-core pnpm pnpm i @triptyk/nfw-core","title":"Installation"},{"location":"getting-started/installation/#installation","text":"","title":"Installation"},{"location":"getting-started/installation/#npm","text":"npm i @triptyk/nfw-core","title":"npm"},{"location":"getting-started/installation/#pnpm","text":"pnpm i @triptyk/nfw-core","title":"pnpm"},{"location":"getting-started/middleware/","text":"Middleware are simple chained functions that have access to the request context and can choose to execute other downstream middlewares. In NFW, middlewares are classes implementing the MiddlewareInterface. The MiddlewareInterface requires you to implement the \"use\" function which acts like a classic Koa middleware. middleware.ts import { RouterContext } from '@koa/router' import { injectable , MiddlewareInterface } from '@triptyk/nfw-core' ; import { Next } from 'koa' ; export class Middleware implements MiddlewareInterface { async use ( context : RouterContext , next : Next ) { // eslint-disable-next-line no-console console . log ( context . method , context . url , context . ip ); await next (); } } Note By default, a new middleware instance will be created for each place the middleware is used. You can change this behavior by using the @singleton decorator. More infos Middlewares are applied on an endpoint with the @UseMiddleware decorators. Middleware can be applied at application level (globalMiddlewares), controller level and route level . application.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @Controller ( '/users' ) @UseMiddleware ( Middleware ) // (1) export class UsersController { @GET ( '/' ) list () { return users ; } @DELETE ( '/:id' ) remove ( @Param ( 'id' ) id : string ) { users = users . filter (( u ) => u . name !== id ); } @POST ( '/' ) create ( @Body () body : User ) { users . push ( body ); return body ; } @GET ( '/:id' ) get ( @Param ( ':id' ) id : string ) { return users . find (( e ) => e . name === id ); } } Middleware can also be a classic koa middleware like (ctx,next) => ...","title":"Middleware"},{"location":"getting-started/response-handler/","text":"Response Handlers The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } } Using the response handler The response handler can be applied at controller , route or application level. For the controller and route level, you must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard , UseResponseHandler } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { MetaResponseHandler } from './response-handler.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) @UseResponseHandler ( MetaResponseHandler , 'Returns all users of the app' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used. Future improvements In the future, response handlers will probably be chainable.","title":"Response handler"},{"location":"getting-started/response-handler/#response-handlers","text":"The purpose of the response handler is to handle the response returned by the controller action. If you use this, you need to handle the sending of the response by yourself. In the example below, i've created a response handler that adds to the response some metadata. response-handler.ts import { RouterContext } from '@koa/router' ; import { Args , Ctx , Ip , Method , ResponseHandlerInterface } from '@triptyk/nfw-core' ; export class MetaResponseHandler implements ResponseHandlerInterface { handle ( previousResponse : unknown , @Ctx () ctx : RouterContext , @Method () method : string , @Ip () ip : string , @Args () [ description ] : [ string ]) : void | Promise < void > { ctx . response . body = { data : controllerResponse , meta : { method , ip , description } } } }","title":"Response Handlers"},{"location":"getting-started/response-handler/#using-the-response-handler","text":"The response handler can be applied at controller , route or application level. For the controller and route level, you must use the @UseResponseHandler(ResponseHabdler, ...args) decorator. The args passed to the @UseResponseHandler will be passed to the response handler and can be retrieved by using the @Args() decorator. controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject , UseGuard , UseResponseHandler } from '@triptyk/nfw-core' ; import { IpGuard } from './guard.js' ; import { Middleware } from './middleware.js' ; import { MetaResponseHandler } from './response-handler.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @UseGuard ( IpGuard , '::1' ) @UseResponseHandler ( MetaResponseHandler , 'Nothing to say' ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) @UseResponseHandler ( MetaResponseHandler , 'Returns all users of the app' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } } Response handler order The response handler closest to the route is used. Ex: If a response handler is applied at route-level and another to the controller-level, the route-level one will be used. Future improvements In the future, response handlers will probably be chainable.","title":"Using the response handler"},{"location":"getting-started/service/","text":"Service There's no specific interfaces to declare a service, all you need to do is decorate your class with @singleton . The rest is up to you. For this example, we're going to create a users service to manage CRUD of users. Create the service service.ts import { singleton } from 'tsyringe' ; export interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @singleton () export class UsersService { addUser ( user : User ) { users . push ( user ); return user ; } removeUser ( name : string ) { users = users . filter (( e ) => e . name === name ); } updateUser ( name : string , body : Partial < User > ) { const idx = users . findIndex (( e ) => e . name === name ); if ( idx === - 1 ) { throw new Error ( 'User not found' ); } return users [ idx ] = { ... users [ idx ], ... body }; } getUser ( name : string ) { return users . find (( e ) => e . name === name ); } getUsers () { return users ; } } Inject the service For the service to be used you need to @inject it and mark the class as @injectable . controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Service"},{"location":"getting-started/service/#service","text":"There's no specific interfaces to declare a service, all you need to do is decorate your class with @singleton . The rest is up to you. For this example, we're going to create a users service to manage CRUD of users.","title":"Service"},{"location":"getting-started/service/#create-the-service","text":"service.ts import { singleton } from 'tsyringe' ; export interface User { name : string , } let users : User [] = [ { name : 'Amaury' }, { name : 'Gilles' } ]; @singleton () export class UsersService { addUser ( user : User ) { users . push ( user ); return user ; } removeUser ( name : string ) { users = users . filter (( e ) => e . name === name ); } updateUser ( name : string , body : Partial < User > ) { const idx = users . findIndex (( e ) => e . name === name ); if ( idx === - 1 ) { throw new Error ( 'User not found' ); } return users [ idx ] = { ... users [ idx ], ... body }; } getUser ( name : string ) { return users . find (( e ) => e . name === name ); } getUsers () { return users ; } }","title":"Create the service"},{"location":"getting-started/service/#inject-the-service","text":"For the service to be used you need to @inject it and mark the class as @injectable . controller.ts import { Controller , GET , DELETE , POST , Param , Body , UseMiddleware , injectable , inject } from '@triptyk/nfw-core' ; import { Middleware } from './middleware.js' ; import { User , UsersService } from './service.js' ; @Controller ( '/users' ) @UseMiddleware ( Middleware ) @injectable () export class UsersController { // eslint-disable-next-line no-useless-constructor constructor ( @inject ( UsersService ) private usersService : UsersService ) {} @GET ( '/' ) list () { return this . usersService . getUsers (); } @DELETE ( '/:name' ) remove ( @Param ( 'name' ) name : string ) { this . usersService . removeUser ( name ); } @POST ( '/' ) create ( @Body () body : User ) { return this . usersService . addUser ( body ); } @GET ( '/:name' ) get ( @Param ( ':name' ) name : string ) { return this . usersService . getUser ( name ); } }","title":"Inject the service"},{"location":"getting-started/web-server/","text":"First, we'll need to create the web-server itself with the createApplication function. The purpose of this function is to setup application's routing and register global elements. application.ts import createApplication from '@triptyk/nfw-core' ; async function init () { /** * Create the app */ const koaApp = await createApplication ({ controllers : [], globalGuards : [], globalMiddlewares : [], baseRoute : '/api/v1' // (1) }); const port = 8001 ; koaApp . listen ( port , () => { console . log ( `Listening on port ${ port } ` ); }); } init (); The baseRoute is the prefix before all controller's routes.","title":"Creating the Web server"}]}